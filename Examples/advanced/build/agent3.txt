/* This type of agent partecipate to the leader election algorithm. */

:- use_module(library(random)).
:- use_module(library(system)).

/* left and right are dynamic clauses used to remember which agents are to the left and right of the current. */
:- dynamic left/1.
:- dynamic right/1.
:- dynamic myid/1.

:- dynamic replyLeft/1.
:- dynamic replyRight/1.

/* This method is invoked when the master node send an init message. */
initE(Id) :> 
            print('Agent init->'), 
            print('Id:'), print(Id), nl,
            assert(myid(Id)),
            L is (Id-1) mod 4, assert(left(L)),
            R is (Id+1) mod 4, assert(right(R)),
            print('dx:'),print(R),print(' sx:'),print(L),nl,
            start(Id).

/* This method is called only one during the initialization, each agent sleeps for a random time to simulate asynchronous wake-up. */
start(Id) :-
          right(RightAgent),
          X=agent, getAgentName(X,RightAgent,Result), 
          format(user_output, 'election(~w,~w,~w,~w)', [Id,Id,0,1]), nl,
          messageA(Result,send_message(election(Id, Id, 0, 1), Me)).
          

/* This method is used to get the user agent name from left() and right() that is used for send_message primitive. */
getAgentName(AtomicPrefix ,NumericSuffix ,Concatenation) :-
          name(AtomicPrefix, Pfx),
          name(NumericSuffix, Sfx),
          append(Pfx,Sfx,Codes),
          name(Concatenation,Codes).

/* React to election msg, if the id is greater than this node's id and this node is in the boundary, forward the msg. */
electionE(Id, SenderId, Phase, Distance) :>
        handleEvent(Id, SenderId, Phase, Distance).


handleEvent(Id, SenderId, Phase, Distance) :-
         print(election_chiamato_from_),print(SenderId), nl,
         myid(MyId),
          ( 
            Id > MyId -> 
                        FDistance is Distance/1,
                      (
                        FDistance =:= 2**Phase -> print(fdistance_uguale_duephase),nl, sendReply(Id, SenderId, Phase, Distance);
                        FDistance < 2**Phase -> print(fdistance_minore_duephase),nl, NewDist is Distance + 1, forwardElection(Id, MyId, Phase, NewDist);
                        print(post_instance),
                        FDistance > 2**Phase -> print(errore_fd)
                      );
            Id == MyId -> announce(MyId); 
            Id < MyId -> print(non_inoltro),nl,nl
          ).

announce(Id) :- messageA(agent1, send_message(leader(Id), Me)).


/* If the election comes from the node to the left, forward it to the node to the right. */
forwardElection(Id, SenderId, Phase, NewDist) :-
          left(LeftAgent),
          right(RightAgent),
          (
            Id == LeftAgent -> sendElectionToAgent(RightAgent, Id, Phase, NewDist);
            Id == RightAgent -> sendElectionToAgent(LeftAgent, Id, Phase, NewDist)
          ).          

sendElectionToAgent(AgentCode, Id, Phase, NewDist) :- 
          X=agent, getAgentName(X, AgentCode, Result), 
          myid(MyId),
          print(forward_election_from_),print(MyId),print(to),print(AgentCode),nl,
          print(forward_content_is_id_),print(Id),print(phase_),print(Phase),print(dist),print(NewDist),nl,
          messageA(Result,send_message(election(Id, MyId, Phase, NewDist), Me)).
          
/* messageA(Result,send_message(election(Id, MyId, Phase, NewDist), Me)). */ 

/* messageA(Result, execute_proc(handleEvent(Id, MyId, Phase, NewDist), Me)). */

sendReply(Id, SenderId, Phase, Distance) :- 
          myid(MyId),
          print(send_reply_from_user_), print(MyId), nl,
          left(LeftAgent),
          right(RightAgent),
          (
            SenderId == LeftAgent -> sendReplyToAgent(LeftAgent, Id, Phase, Distance);
            SenderId == RightAgent -> sendReplyToAgent(RightAgent, Id, Phase, Distance)
          ).

sendReplyToAgent(AgentCode, Id, Phase, Distance) :- 
          print(send_reply_to_agent_), print(AgentCode), nl, nl,
          X=agent, getAgentName(X, AgentCode, Result), 
          myid(MyId),
          messageA(Result, send_message(reply(Id, MyId, Phase, Distance), Me)).

replyE(Id, SenderId, Phase, Distance) :> 
          myid(MyId),
          left(LeftAgent),
          right(RightAgent),
          print(ho_ricevuto_reply_da_), print(SenderId), nl,
          (
            Id == MyId -> 
                (
                    LeftAgent == SenderId -> replyFromLeft(Id, Phase, Distance);
                    RightAgent == SenderId -> replyFromRight(Id, Phase, Distance)
                );
            forwardReply(Id, SenderId, Phase, Distance)
          ).

replyFromLeft(Id, Phase, Distance) :- 
          left(LeftAgent),
          assert(replyLeft(LeftAgent)),
          right(RightAgent),
          replyRight(ReplyRight),
          print(vado_nella_next), nl, 
          goNextPhase(Phase).

replyFromRight(Id, Phase, Distance) :-
          right(RightAgent),
          print(sto_eseguendo_reply_from_right), print(RightAgent), nl,
          assert(replyRight(RightAgent)),  
          left(LeftAgent),
          X=agent, getAgentName(X,LeftAgent,Result),
          myid(MyId),
          print(torno_dietro_invio_handle_event_from),print(MyId),print(to),print(Result),print(with_val_id_),print(Id),
          print(distance_),print(Distance),print(and_phase_),print(Phase),nl,nl,
          messageA(Result,execute_proc(handleEvent(Id, Id,  Phase, 1), Me)).

/* If the reply comes from the node to the left, forward it to the node to the right. */
forwardReply(Id, SenderId, Phase, Distance) :- 
          left(LeftAgent),
          right(RightAgent),
          (
              SenderId == LeftAgent -> sendReplyToAgent(RightAgent, Id, Phase, Distance);
              SenderId == RightAgent -> sendReplyToAgent(LeftAgent, Id, Phase, Distance)
          ).

/* When an agent recevies both replies, it can proceed to the next phase. */
goNextPhase(Phase) :-
          print(sono_go_next_phase),nl,
          NextPhase is Phase + 1,
          right(RightAgent), myid(MyId),
          X=agent, getAgentName(X,RightAgent,Result),
          print(mando_a_), print(Result), nl, 
          myid(MioId),
          print(io_sono_), print(MioId), nl,
          messageA(Result, execute_proc(handleEvent(MioId, MioId, NextPhase, 1), Me)),
          print(ho_inviato).

testE(Id) :> 
      print(ci_sono),
      print(Id),nl,
      integer(Id),
      print(se_stampo_allora_id_is_intero),nl.

t(Id) :- print(sasa_), print(Id), nl.


/* FUNZIONA: messageA(Result,send_message(election(3, 3, NextPhase, 1), This)). */
/* NON FUNZIONA: messageA(Result,send_message(election(MioId, MioId, NextPhase, 1), This)). */