/* This type of agent partecipate to the leader election algorithm. */
:- use_module(library(random)).
:- use_module(library(system)).

/* left and right are dynamic clauses used to remember which agents are to the left and right of the current. */
:- dynamic left/1.
:- dynamic right/1.
:- dynamic myid/1.

/* This method is invoked when the master node send an init message. */
initE(Id) :> 
            print('Agent init->'), 
            print('Id:'), print(Id), nl,
            assert(myid(Id)),
            L is (Id-1) mod 4, assert(left(L)),
            R is (Id+1) mod 4, assert(right(R)),
            print('dx:'),print(R),print(' sx:'),print(L),nl,
            start(Id).

/* This method is called only one during the initialization, each agent sleeps for a random time to simulate asynchronous wake-up. */
start(Id) :-
          right(RightAgent),
          X=agent, getAgentName(X,RightAgent,Result), 
          format(user_output, 'election(~w,~w,~w,~w)', [Id,Id,0,1]), nl,
          messageA(Result,send_message(election([Id, Id, 0, 1]), Me)).
          

/* This method is used to get the user agent name from left() and right() that is used for send_message primitive. */
getAgentName(AtomicPrefix ,NumericSuffix ,Concatenation) :-
          name(AtomicPrefix, Pfx),
          name(NumericSuffix, Sfx),
          append(Pfx,Sfx,Codes),
          name(Concatenation,Codes).

/* React to election msg, if the id is greater than this node's id and this node is in the boundary, forward the msg. */
electionE(List) :>
        unwrap(List, Id, SenderId, Phase, Distance),
        handleEvent(Id, SenderId, Phase, Distance).

unwrap(List, Id, SenderId, Phase, Distance) :-
        nth0(0, List, Id),
        nth0(1, List, SenderId),
        nth0(2, List, Phase),
        nth0(3, List, Distance),
        print(unwrap_id_),print(Id),print(sender_id_),
        print(SenderId),print(phase_),print(Phase),print(distance_),print(Distance),nl,nl.

handleEvent(Id, SenderId, Phase, Distance) :-
         print(election_chiamato_from_),print(SenderId), nl,
         myid(MyId),
          ( 
            Id > MyId -> 
                        FDistance is Distance/1,
                      (
                        FDistance =:= 2**Phase -> print(fdistance_uguale_duephase),nl, sendReply(Id, SenderId, Phase, Distance);
                        FDistance < 2**Phase -> print(fdistance_minore_duephase),nl, NewDist is Distance + 1, forwardElection(Id, SenderId, Phase, NewDist);
                        print(post_instance),
                        FDistance > 2**Phase -> print(errore_fd)
                      );
            Id == MyId -> announce(MyId); 
            Id < MyId -> print(non_inoltro),nl,nl, sendTryOtherSideToAgent(Id, SenderId, Phase, Distance)
          ).

announce(Id) :- 
          nl,nl,print(end),nl,nl,
          messageA(agent4, send_message(leader(Id), Me)).

/* Parte di ritorno dietro. */
sendTryOtherSideToAgent(AgentCode, Id, Phase, Distance) :- 
          print(send_try_other_side_to_agent_), print(AgentCode), nl, nl,
          X=agent, getAgentName(X, AgentCode, Result), 
          myid(MyId),
          L = [Id, MyId, Phase, Distance],
          messageA(Result, send_message(otherSide(L), Me)).

otherSideE(List) :> 
          unwrap(List, Id, SenderId, Phase, Distance),
          myid(MyId),
          left(LeftAgent),
          right(RightAgent),
          print(ho_ricevuto_other_side_da_), print(SenderId), nl,
          (
            Id == MyId -> startNextSide(Id, Phase);
            sendTryOtherSideToAgent(Id, SenderId, Phase, Distance)
          ).          

startNextSide(Id, Phase) :- 
          left(LeftAgent),
          X=agent, getAgentName(X,LeftAgent,Result),
          L = [Id, Id,  Phase, 1],
          messageA(Result,send_message(election(L), Me)).

/* If the election comes from the node to the left, forward it to the node to the right. */
forwardElection(Id, SenderId, Phase, NewDist) :-
          left(LeftAgent),
          right(RightAgent),
          (
            SenderId == LeftAgent -> sendElectionToAgent(RightAgent, Id, Phase, NewDist);
            SenderId == RightAgent -> sendElectionToAgent(LeftAgent, Id, Phase, NewDist)
          ).          

sendElectionToAgent(AgentCode, Id, Phase, NewDist) :- 
          X=agent, getAgentName(X, AgentCode, Result), 
          myid(MyId),
          print(forward_election_from_),print(MyId),print(to),print(AgentCode),nl,
          print(forward_content_is_id_),print(Id),print(phase_),print(Phase),print(dist),print(NewDist),nl,
          L = [Id, MyId, Phase, NewDist],
          messageA(Result,send_message(election(L), Me)).
          
/* messageA(Result,send_message(election(Id, MyId, Phase, NewDist), Me)). */ 

/* messageA(Result, execute_proc(handleEvent(Id, MyId, Phase, NewDist), Me)). */

sendReply(Id, SenderId, Phase, Distance) :- 
          myid(MyId),
          print(send_reply_from_user_), print(MyId), nl,
          left(LeftAgent),
          right(RightAgent),
          (
            SenderId == LeftAgent -> sendReplyToAgent(LeftAgent, Id, Phase, Distance);
            SenderId == RightAgent -> sendReplyToAgent(RightAgent, Id, Phase, Distance)
          ).

sendReplyToAgent(AgentCode, Id, Phase, Distance) :- 
          print(send_reply_to_agent_), print(AgentCode), nl, nl,
          X=agent, getAgentName(X, AgentCode, Result), 
          myid(MyId),
          L = [Id, MyId, Phase, Distance],
          messageA(Result, send_message(reply(L), Me)).

replyE(List) :> 
          unwrap(List, Id, SenderId, Phase, Distance),
          myid(MyId),
          left(LeftAgent),
          right(RightAgent),
          print(ho_ricevuto_reply_da_), print(SenderId), nl,
          (
            Id == MyId -> 
                (
                    LeftAgent == SenderId -> replyFromLeft(Id, Phase, Distance);
                    RightAgent == SenderId -> replyFromRight(Id, Phase, Distance)
                );
            forwardReply(Id, SenderId, Phase, Distance)
          ).

replyFromLeft(Id, Phase, Distance) :- 
          left(LeftAgent),
          right(RightAgent),
          print(vado_nella_next), nl, 
          goNextPhase(Phase).

replyFromRight(Id, Phase, Distance) :-
          right(RightAgent),
          print(sto_eseguendo_reply_from_right), print(RightAgent), nl,
          left(LeftAgent),
          X=agent, getAgentName(X,LeftAgent,Result),
          myid(MyId),
          print(torno_dietro_invio_handle_event_from),print(MyId),print(to),print(Result),print(with_val_id_),print(Id),
          print(distance_),print(Distance),print(and_phase_),print(Phase),nl,nl,
          L = [Id, Id,  Phase, 1],
          messageA(Result,send_message(election(L), Me)).

/* If the reply comes from the node to the left, forward it to the node to the right. */
forwardReply(Id, SenderId, Phase, Distance) :- 
          left(LeftAgent),
          right(RightAgent),
          (
              SenderId == LeftAgent -> sendReplyToAgent(RightAgent, Id, Phase, Distance);
              SenderId == RightAgent -> sendReplyToAgent(LeftAgent, Id, Phase, Distance)
          ).

/* When an agent recevies both replies, it can proceed to the next phase. */
goNextPhase(Phase) :-
          print(sono_go_next_phase),nl,
          NextPhase is Phase + 1,
          right(RightAgent), myid(MyId),
          X=agent, getAgentName(X,RightAgent,Result),
          print(mando_a_), print(Result), nl, 
          myid(MioId),
          print(io_sono_), print(MioId), nl,
          L = [MioId, MioId, NextPhase, 1],
          messageA(Result, send_message(election(L), Me)).
